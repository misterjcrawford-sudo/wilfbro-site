<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Math Invaders</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link href="https://fonts.googleapis.com/css2?family=Silkscreen:wght@400;700&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet" />
<style>
  :root {
    --bg: #000;
    --neon: #39ff14;
    --white: #fff;
    --danger: #ff4444;
    --hot-pink: #ff2ea6;
  }

  * { box-sizing: border-box; }

  body {
    margin: 0;
    background: var(--bg);
    color: var(--neon);
    font-family: "Space Grotesk", system-ui, -apple-system, "Helvetica Neue", Arial, sans-serif;
    text-shadow: 0 0 6px rgba(57, 255, 20, 0.6);
  }

  .game-wrap {
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
    padding: 10px;
  }

  .home-nav {
    display: flex;
    justify-content: flex-end;
    margin-bottom: 8px;
  }

  .home-btn {
    display: inline-block;
    text-decoration: none;
    color: #111111;
    background: #ffffff;
    border: 1px solid #000000;
    padding: 6px 10px;
    font-family: "Space Grotesk", system-ui, -apple-system, "Helvetica Neue", Arial, sans-serif;
    font-size: 0.76rem;
    letter-spacing: 0.02em;
    line-height: 1;
    text-shadow: none;
    transition: background-color 140ms ease, color 140ms ease;
  }

  .home-btn:hover {
    background: #ff4fb4;
    color: #000000;
  }

  .title {
    margin: 0 0 10px;
    font-size: clamp(1.6rem, 3vw, 2.1rem);
    letter-spacing: 0.08em;
    font-weight: 400;
    font-family: "Silkscreen", monospace;
  }

  .hud {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 10px;
    align-items: center;
    margin-bottom: 8px;
  }

  .stats {
    display: flex;
    flex-wrap: wrap;
    gap: 14px;
    font-size: 16px;
  }

  .stats span {
    border: 1px solid var(--hot-pink);
    border-radius: 999px;
    padding: 6px 12px;
    background: rgba(255, 46, 166, 0.12);
    color: var(--hot-pink);
    text-shadow: 0 0 8px rgba(255, 46, 166, 0.55);
  }

  #questionLabel {
    background: var(--hot-pink);
    color: #000;
    text-shadow: none;
    font-weight: 500;
  }

  .difficulty {
    display: inline-flex;
    gap: 6px;
    align-items: center;
    font-size: 14px;
    color: var(--hot-pink);
    text-shadow: 0 0 8px rgba(255, 46, 166, 0.55);
  }

  .diff-btn {
    border: 1px solid var(--hot-pink);
    background: transparent;
    color: var(--hot-pink);
    font: inherit;
    padding: 5px 10px;
    cursor: pointer;
    text-shadow: 0 0 8px rgba(255, 46, 166, 0.55);
  }

  .diff-btn.active {
    background: var(--hot-pink);
    color: #000;
    text-shadow: none;
  }

  .play-area {
    position: relative;
    width: 100%;
    border: 2px solid var(--neon);
    box-shadow: 0 0 10px rgba(57, 255, 20, 0.35) inset;
  }

  canvas {
    display: block;
    width: 100%;
    height: 500px;
    background: #000;
  }

  .tap-zones {
    position: absolute;
    inset: 0;
    display: flex;
    pointer-events: auto;
  }

  .zone {
    flex: 1;
    background: transparent;
    touch-action: none;
  }

  .zone.center { flex: 0.8; }

  @media (min-width: 900px) {
    .tap-zones { display: none; }
  }
</style>
</head>
<body>
  <div class="game-wrap">
    <div class="home-nav">
      <a class="home-btn" href="index.html">Back to wilfbro</a>
    </div>
    <h1 class="title">Math Invaders</h1>
    <div class="hud">
      <div class="stats">
        <span id="questionLabel">Question: 0 + 0 = ?</span>
        <span id="scoreLabel">Score: 0</span>
        <span id="livesLabel">Lives: 3</span>
        <span id="difficultyLabel">Difficulty: Easy</span>
      </div>
      <div class="difficulty" aria-label="Difficulty selector">
        <span>Mode</span>
        <button class="diff-btn active" data-diff="easy" type="button">Easy</button>
        <button class="diff-btn" data-diff="medium" type="button">Medium</button>
        <button class="diff-btn" data-diff="hard" type="button">Hard</button>
      </div>
    </div>

    <div class="play-area">
      <canvas id="gameCanvas" width="1000" height="500"></canvas>
      <div class="tap-zones" aria-hidden="true">
        <div class="zone left" data-zone="left"></div>
        <div class="zone center" data-zone="center"></div>
        <div class="zone right" data-zone="right"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  const NumberInvaders = {
    canvas: null,
    ctx: null,
    ui: {},

    width: 1000,
    height: 500,

    state: "start", // start | playing | gameover
    difficulty: "easy",
    score: 0,
    lives: 3,
    correctHits: 0,

    question: null,
    aliens: [],
    bullets: [],
    explosions: [],

    flashTimer: 0,
    lastTime: 0,
    shootCooldown: 0,

    input: {
      left: false,
      right: false,
      shoot: false
    },

    audio: {
      ctx: null,
      master: null,
      timer: null,
      started: false,
      step: 0,
      nextNoteTime: 0,
      bpm: 78
    },

    player: {
      x: 500,
      y: 460,
      width: 56,
      height: 24,
      speed: 360
    },

    init() {
      this.canvas = document.getElementById("gameCanvas");
      this.ctx = this.canvas.getContext("2d");

      this.ui.question = document.getElementById("questionLabel");
      this.ui.score = document.getElementById("scoreLabel");
      this.ui.lives = document.getElementById("livesLabel");
      this.ui.diff = document.getElementById("difficultyLabel");

      this.bindDifficultyButtons();
      this.bindInput();
      this.resize();
      window.addEventListener("resize", () => this.resize());

      this.updateHud();
      requestAnimationFrame((t) => this.gameLoop(t));
    },

    bindDifficultyButtons() {
      const buttons = document.querySelectorAll(".diff-btn");
      buttons.forEach((btn) => {
        btn.addEventListener("click", () => {
          this.startMusic();
          const next = btn.dataset.diff;
          this.difficulty = next;
          buttons.forEach((b) => b.classList.toggle("active", b === btn));
          this.resetForDifficultyChange();
        });
      });
    },

    bindInput() {
      // Extra unlock hooks for stricter browser autoplay policies.
      window.addEventListener("pointerdown", () => this.startMusic());
      window.addEventListener("keydown", () => this.startMusic());

      window.addEventListener("keydown", (e) => {
        if (e.code === "ArrowLeft") {
          this.input.left = true;
          e.preventDefault();
        }
        if (e.code === "ArrowRight") {
          this.input.right = true;
          e.preventDefault();
        }
        if (e.code === "Space") {
          e.preventDefault();
          this.startMusic();
          if (this.state === "start") {
            this.startGame();
            return;
          }
          if (this.state === "gameover") {
            this.restartGame();
            return;
          }
          this.input.shoot = true;
        }
      });

      window.addEventListener("keyup", (e) => {
        if (e.code === "ArrowLeft") this.input.left = false;
        if (e.code === "ArrowRight") this.input.right = false;
      });

      const zones = document.querySelectorAll(".zone");
      zones.forEach((zone) => {
        const type = zone.dataset.zone;

        zone.addEventListener("touchstart", (e) => {
          e.preventDefault();
          this.startMusic();
          if (this.state === "start") {
            this.startGame();
            return;
          }
          if (this.state === "gameover") {
            this.restartGame();
            return;
          }
          if (type === "left") this.input.left = true;
          if (type === "right") this.input.right = true;
          if (type === "center") this.input.shoot = true;
        }, { passive: false });

        zone.addEventListener("touchend", (e) => {
          e.preventDefault();
          if (type === "left") this.input.left = false;
          if (type === "right") this.input.right = false;
        }, { passive: false });

        zone.addEventListener("touchcancel", () => {
          if (type === "left") this.input.left = false;
          if (type === "right") this.input.right = false;
        });
      });
    },

    resize() {
      const rect = this.canvas.getBoundingClientRect();
      const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
      this.canvas.width = Math.floor(rect.width * dpr);
      this.canvas.height = Math.floor(500 * dpr);
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.width = rect.width;
      this.height = 500;
      this.player.y = this.height - 34;
      this.player.x = Math.min(Math.max(this.player.x, this.player.width / 2), this.width - this.player.width / 2);
    },

    resetForDifficultyChange() {
      this.score = 0;
      this.lives = 3;
      this.correctHits = 0;
      this.flashTimer = 0;
      this.shootCooldown = 0;
      this.player.x = this.width / 2;
      this.bullets = [];
      this.explosions = [];
      this.generateQuestion();
      this.generateAliens();
      this.state = "start";
      this.updateHud();
    },

    startGame() {
      this.score = 0;
      this.lives = 3;
      this.correctHits = 0;
      this.flashTimer = 0;
      this.shootCooldown = 0;
      this.player.x = this.width / 2;
      this.bullets = [];
      this.explosions = [];
      this.generateQuestion();
      this.generateAliens();
      this.state = "playing";
      this.updateHud();
    },

    restartGame() {
      this.startGame();
    },

    initAudio() {
      if (this.audio.ctx) return;
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (!Ctx) return;
      this.audio.ctx = new Ctx();
      this.audio.master = this.audio.ctx.createGain();
      this.audio.master.gain.value = 0.16;
      this.audio.master.connect(this.audio.ctx.destination);
      this.audio.nextNoteTime = this.audio.ctx.currentTime + 0.08;
    },

    startMusic() {
      this.initAudio();
      const a = this.audio;
      if (!a.ctx || a.started) return;
      a.ctx.resume();
      a.started = true;
      // Soft cue so users can hear that audio unlocked.
      this.playLead(72, a.ctx.currentTime + 0.02, 0.12);
      a.timer = setInterval(() => this.scheduleLoFi(), 90);
    },

    scheduleLoFi() {
      const a = this.audio;
      if (!a.ctx) return;
      const stepDur = 60 / a.bpm / 4; // 16th notes

      while (a.nextNoteTime < a.ctx.currentTime + 0.35) {
        this.playLoFiStep(a.nextNoteTime, a.step);
        a.nextNoteTime += stepDur;
        a.step = (a.step + 1) % 64;
      }
    },

    playLoFiStep(time, step) {
      const bar = Math.floor(step / 16) % 4;
      const beat = step % 16;
      const progression = [48, 45, 43, 41]; // C3, A2, G2, F2
      const root = progression[bar];

      // Soft kick on 1 and 3.
      if (beat === 0 || beat === 8) this.playKick(time);
      // Soft hat on offbeats.
      if (beat % 4 === 2) this.playHat(time);
      // Bass pulse.
      if (beat % 4 === 0) this.playBass(root, time, 0.22);
      // Chord stabs.
      if (beat === 0 || beat === 8) this.playChord([root, root + 3, root + 7], time + 0.01, 0.45);
      // Sparse top note.
      if (beat === 6 || beat === 14) this.playLead(root + 12 + (beat === 14 ? 2 : 0), time, 0.18);
    },

    midiToFreq(midi) {
      return 440 * Math.pow(2, (midi - 69) / 12);
    },

    playKick(time) {
      const a = this.audio;
      if (!a.ctx) return;
      const osc = a.ctx.createOscillator();
      const gain = a.ctx.createGain();
      osc.type = "sine";
      osc.frequency.setValueAtTime(130, time);
      osc.frequency.exponentialRampToValueAtTime(42, time + 0.12);
      gain.gain.setValueAtTime(0.0001, time);
      gain.gain.exponentialRampToValueAtTime(0.35, time + 0.006);
      gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.14);
      osc.connect(gain).connect(a.master);
      osc.start(time);
      osc.stop(time + 0.16);
    },

    playHat(time) {
      const a = this.audio;
      if (!a.ctx) return;
      const buffer = a.ctx.createBuffer(1, Math.floor(a.ctx.sampleRate * 0.04), a.ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
      const src = a.ctx.createBufferSource();
      const highpass = a.ctx.createBiquadFilter();
      const gain = a.ctx.createGain();
      highpass.type = "highpass";
      highpass.frequency.value = 6000;
      gain.gain.setValueAtTime(0.08, time);
      gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.045);
      src.buffer = buffer;
      src.connect(highpass).connect(gain).connect(a.master);
      src.start(time);
      src.stop(time + 0.05);
    },

    playBass(midi, time, len) {
      const a = this.audio;
      if (!a.ctx) return;
      const osc = a.ctx.createOscillator();
      const filter = a.ctx.createBiquadFilter();
      const gain = a.ctx.createGain();
      osc.type = "triangle";
      osc.frequency.value = this.midiToFreq(midi - 12);
      filter.type = "lowpass";
      filter.frequency.value = 340;
      gain.gain.setValueAtTime(0.0001, time);
      gain.gain.exponentialRampToValueAtTime(0.12, time + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, time + len);
      osc.connect(filter).connect(gain).connect(a.master);
      osc.start(time);
      osc.stop(time + len + 0.02);
    },

    playChord(notes, time, len) {
      const a = this.audio;
      if (!a.ctx) return;
      notes.forEach((midi) => {
        const osc = a.ctx.createOscillator();
        const gain = a.ctx.createGain();
        osc.type = "sine";
        osc.frequency.value = this.midiToFreq(midi);
        gain.gain.setValueAtTime(0.0001, time);
        gain.gain.exponentialRampToValueAtTime(0.035, time + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.0001, time + len);
        osc.connect(gain).connect(a.master);
        osc.start(time);
        osc.stop(time + len + 0.02);
      });
    },

    playLead(midi, time, len) {
      const a = this.audio;
      if (!a.ctx) return;
      const osc = a.ctx.createOscillator();
      const gain = a.ctx.createGain();
      osc.type = "square";
      osc.frequency.value = this.midiToFreq(midi);
      gain.gain.setValueAtTime(0.0001, time);
      gain.gain.exponentialRampToValueAtTime(0.03, time + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, time + len);
      osc.connect(gain).connect(a.master);
      osc.start(time);
      osc.stop(time + len + 0.02);
    },

    // generateQuestion()
    generateQuestion() {
      let a = 0;
      let b = 0;
      let op = "+";
      let answer = 0;

      if (this.difficulty === "easy") {
        a = this.randInt(1, 19);
        b = this.randInt(1, 19);
        if (a + b > 20) b = 20 - a;
        op = "+";
        answer = a + b;
      } else if (this.difficulty === "medium") {
        op = Math.random() < 0.5 ? "+" : "-";
        if (op === "+") {
          a = this.randInt(10, 79);
          b = this.randInt(1, 20);
          if (a + b > 99) b = 99 - a;
          answer = a + b;
        } else {
          a = this.randInt(20, 99);
          b = this.randInt(1, a);
          answer = a - b;
        }
      } else {
        a = this.randInt(1, 12);
        b = this.randInt(1, 12);
        op = "×";
        answer = a * b;
      }

      this.question = {
        text: `${a} ${op} ${b} = ?`,
        answer
      };
    },

    // generateAliens()
    generateAliens() {
      const count = 6;
      const alienW = 74;
      const gap = 14;
      const totalW = count * alienW + (count - 1) * gap;
      const startX = Math.max(12, (this.width - totalW) / 2);
      const y = 85;

      const values = this.buildAnswerSet(this.question.answer, count);
      this.shuffle(values);

      const baseDrop = this.difficulty === "easy" ? 18 : this.difficulty === "medium" ? 22 : 26;
      const speedBoost = Math.floor(this.correctHits / 5) * 2.4;
      const fallSpeed = baseDrop + speedBoost;

      this.aliens = values.map((val, i) => ({
        value: val,
        correct: val === this.question.answer,
        baseX: startX + i * (alienW + gap),
        x: startX + i * (alienW + gap),
        y,
        width: alienW,
        height: 42,
        phase: Math.random() * Math.PI * 2,
        amp: 8 + Math.random() * 6,
        speedY: fallSpeed,
        alive: true
      }));
    },

    buildAnswerSet(correct, count) {
      const set = new Set([correct]);
      const spread = this.difficulty === "hard" ? 28 : 16;
      while (set.size < count) {
        const offset = this.randInt(-spread, spread);
        const candidate = Math.max(0, correct + offset + (offset === 0 ? this.randInt(1, 6) : 0));
        set.add(candidate);
      }
      return [...set];
    },

    // handleInput()
    handleInput(dt) {
      if (this.input.left) this.player.x -= this.player.speed * dt;
      if (this.input.right) this.player.x += this.player.speed * dt;

      const half = this.player.width / 2;
      if (this.player.x < half) this.player.x = half;
      if (this.player.x > this.width - half) this.player.x = this.width - half;

      if (this.input.shoot && this.shootCooldown <= 0) {
        this.bullets.push({ x: this.player.x, y: this.player.y - 14, vy: -460, r: 3 });
        this.shootCooldown = 0.18;
      }
      this.input.shoot = false;
    },

    // update()
    update(dt, nowSec) {
      if (this.state !== "playing") return;

      this.shootCooldown = Math.max(0, this.shootCooldown - dt);
      this.flashTimer = Math.max(0, this.flashTimer - dt);

      this.handleInput(dt);

      for (const b of this.bullets) {
        b.y += b.vy * dt;
      }
      this.bullets = this.bullets.filter((b) => b.y > -10);

      for (const a of this.aliens) {
        if (!a.alive) continue;
        a.y += a.speedY * dt;
        a.x = a.baseX + Math.sin(nowSec * 2.2 + a.phase) * a.amp;
      }

      const shipHit = this.aliens.some((a) => {
        if (!a.alive) return false;
        return this.rectOverlap(
          a.x, a.y, a.width, a.height,
          this.player.x - this.player.width / 2,
          this.player.y - this.player.height / 2,
          this.player.width,
          this.player.height
        );
      });
      if (shipHit) {
        this.lives = 0;
        this.state = "gameover";
        this.flashTimer = 0.2;
        this.updateHud();
        return;
      }

      this.handleCollision();

      for (const e of this.explosions) {
        e.life -= dt;
        e.radius += 140 * dt;
      }
      this.explosions = this.explosions.filter((e) => e.life > 0);

      const reachedBottom = this.aliens.some((a) => a.alive && a.y + a.height >= this.height - 28);
      if (reachedBottom) {
        this.lives -= 1;
        if (this.lives <= 0) {
          this.state = "gameover";
        } else {
          this.generateQuestion();
          this.generateAliens();
          this.bullets.length = 0;
        }
        this.updateHud();
      }
    },

    // handleCollision()
    handleCollision() {
      for (const b of this.bullets) {
        for (const a of this.aliens) {
          if (!a.alive) continue;
          if (this.pointInRect(b.x, b.y, a.x, a.y, a.width, a.height)) {
            b.y = -999;

            if (a.correct) {
              a.alive = false;
              this.explosions.push({ x: a.x + a.width / 2, y: a.y + a.height / 2, radius: 6, life: 0.25, color: "#ffffff" });
              this.score += 10;
              this.correctHits += 1;

              // Wave clear bonus behavior.
              this.score += 20;

              this.generateQuestion();
              this.generateAliens();
            } else {
              this.score -= 5;
              this.flashTimer = 0.16;
              this.explosions.push({ x: b.x, y: b.y, radius: 5, life: 0.2, color: "#ff4444" });
              this.lives = 0;
              this.state = "gameover";
            }

            this.updateHud();
            return;
          }
        }
      }

      // If all aliens are gone (safety check), give clear bonus + new wave.
      if (this.aliens.length && this.aliens.every((a) => !a.alive)) {
        this.score += 20;
        this.generateQuestion();
        this.generateAliens();
        this.updateHud();
      }
    },

    // draw()
    draw() {
      const ctx = this.ctx;
      ctx.clearRect(0, 0, this.width, this.height);

      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, this.width, this.height);

      for (let i = 0; i < 70; i++) {
        const x = (i * 137) % this.width;
        const y = (i * 97) % this.height;
        ctx.fillStyle = "rgba(57,255,20,0.06)";
        ctx.fillRect(x, y, 2, 2);
      }

      // Aliens
      for (const a of this.aliens) {
        if (!a.alive) continue;
        ctx.strokeStyle = "#39ff14";
        ctx.lineWidth = 2;
        ctx.strokeRect(a.x, a.y, a.width, a.height);
        ctx.fillStyle = "rgba(57,255,20,0.08)";
        ctx.fillRect(a.x, a.y, a.width, a.height);

        ctx.fillStyle = "#39ff14";
        ctx.font = "600 22px 'Space Grotesk', sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(String(a.value), a.x + a.width / 2, a.y + a.height / 2 + 1);
      }

      // Bullets
      ctx.fillStyle = "#ffffff";
      for (const b of this.bullets) {
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        ctx.fill();
      }

      // Player spaceship
      const p = this.player;
      ctx.fillStyle = "#ffffff";
      const px = 4;
      const shipPattern = [
        "000001100000",
        "000111111000",
        "001111111100",
        "011111111110",
        "111001100111",
        "111111111111",
        "110011110011",
        "100000000001"
      ];
      const shipW = shipPattern[0].length * px;
      const shipH = shipPattern.length * px;
      const startX = Math.round(p.x - shipW / 2);
      const startY = Math.round(p.y - shipH / 2);

      for (let row = 0; row < shipPattern.length; row++) {
        for (let col = 0; col < shipPattern[row].length; col++) {
          if (shipPattern[row][col] === "1") {
            ctx.fillRect(startX + col * px, startY + row * px, px, px);
          }
        }
      }

      // Cockpit accent.
      ctx.fillStyle = "#39ff14";
      ctx.fillRect(startX + 5 * px, startY + 1 * px, 2 * px, px);
      ctx.fillStyle = "#ffffff";

      // Explosions
      for (const e of this.explosions) {
        const alpha = Math.max(0, e.life / 0.25);
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
        ctx.strokeStyle = `${e.color}${this.hexAlpha(alpha)}`;
        ctx.lineWidth = 3;
        ctx.stroke();
      }

      // Wrong shot red flash
      if (this.flashTimer > 0) {
        ctx.fillStyle = `rgba(255, 68, 68, ${this.flashTimer * 1.8})`;
        ctx.fillRect(0, 0, this.width, this.height);
      }

      if (this.state === "start") {
        this.drawOverlay("Press spacebar to start", "Math Invaders");
      } else if (this.state === "gameover") {
        this.drawOverlay(`Game Over — Final Score: ${this.score}`, "Press Space to Restart");
      }
    },

    drawOverlay(line1, line2) {
      const ctx = this.ctx;
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      ctx.fillRect(0, 0, this.width, this.height);
      ctx.textAlign = "center";
      ctx.fillStyle = "#ff2ea6";
      ctx.shadowColor = "rgba(255, 46, 166, 0.65)";
      ctx.shadowBlur = 12;
      ctx.font = "400 16px 'Space Grotesk', sans-serif";
      ctx.fillText(line1, this.width / 2, this.height / 2 - 18);
      ctx.fillStyle = "#39ff14";
      ctx.shadowColor = "rgba(57, 255, 20, 0.65)";
      ctx.font = "400 36px 'Silkscreen', monospace";
      ctx.fillText(line2, this.width / 2, this.height / 2 + 28);
      ctx.shadowBlur = 0;
    },

    updateHud() {
      const pretty = this.difficulty.charAt(0).toUpperCase() + this.difficulty.slice(1);
      this.ui.question.textContent = `Question: ${this.question ? this.question.text : "0 + 0 = ?"}`;
      this.ui.score.textContent = `Score: ${this.score}`;
      this.ui.lives.textContent = `Lives: ${this.lives}`;
      this.ui.diff.textContent = `Difficulty: ${pretty}`;
    },

    gameLoop(ts) {
      const now = ts * 0.001;
      const dt = Math.min(0.033, this.lastTime ? now - this.lastTime : 0.016);
      this.lastTime = now;

      this.update(dt, now);
      this.draw();
      requestAnimationFrame((t) => this.gameLoop(t));
    },

    pointInRect(px, py, x, y, w, h) {
      return px >= x && px <= x + w && py >= y && py <= y + h;
    },

    rectOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    },

    randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    },

    shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }
    },

    hexAlpha(a) {
      const clamped = Math.max(0, Math.min(1, a));
      return Math.floor(clamped * 255).toString(16).padStart(2, "0");
    }
  };

  window.NumberInvaders = NumberInvaders;
  NumberInvaders.init();
})();
</script>
</body>
</html>
